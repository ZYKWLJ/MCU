# 1.本身内存
结构体的内存大小是所有的成员变量的内存大小的总和。但是`可能`会有内存对齐的问题。

# 2.内存对齐

## 2.1 为什么对齐(背景)？——CPU读取快！
内存对齐是为了`提高内存的访问效率`。在许多计算机体系结构中，访问`未对齐的内存`可能会导致`性能下降或引发硬件异常`。例如，对于32位机来说，`4字节对齐能够使cpu访问速度提高`，比如说一个long类型的变量，如果`跨越了4字节边界存储`，那么`cpu要读取两次，这样效率就低了`。因此，结构体对齐是一种重要的`优化`机制，它确保结构体成员被`合理地分配到内存中`，以`最大程度`地提高程序的性能。



## 2.2 对齐规则
```
1.大小必须是对其因子的整数倍

2.每个地址相对于上一个的偏移量必须是对其因子的整数倍
```

### 2.2.1 自然对齐--默认为4
自然对齐要求结构体的`总大小是最大成员变量的大小的整数倍`。
并且在32位机中，一般对齐边界是`4字节对齐`的。`每一个成员大小都必须是对齐因子的整数倍`，这样便于CPU一次性可以读取4字节的数据。不必再读取两次。
例子：[](../3.结构体/test/testAlign.c)
```c
struct Example//供16位大小
{
    char a;//1+3(对齐填充的)
    int b;//4
    double c;//8
};
```

#### 补充，32位访问机制
在 32 位计算机系统中，CPU 的`数据总线宽度通常是 32 位`，也就是 `4 字节`。这意味着 `CPU 在一次`内存访问操作中，能够读取或者写入 4 字节的数据。CPU 会按照 4 字节为`一个单位`从`内存中读取数据`，这些 4 字节的内存块被`称作一个内存访问单位`。

---
### 2.2.2控制对齐--#pragma pack
`#pragma pack` 指令是一种`编译器特定的方式`，用于`指定结构体的对齐方式`。可以指定对其因子，每一个成员的大小`都必须是对其因子的整数倍`。

注意，只能设置对齐策略为1，2，4，8，等`2的幂次方字节数`！
```c
#pragma pack(push, n)//将当前对齐设置保存在栈中，并将对齐设置为 n 字节。
// 结构体定义
#pragma pack(pop)//从栈中恢复之前的对齐设置。
```
例如，一下代码将结构体的对齐设置为 2 字节：
```c
#pragma pack(push, 2)
struct Example {
    char a;
    int b;
    double c;
};
#pragma pack(pop)
```